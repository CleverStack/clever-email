var Class = require( 'uberclass' )
  , async = require( 'async' )
  , config = require( 'config' )
  , models = require( 'models' )
  , services = require( 'services' )
  , debug = require( 'debug' )( 'ProcessEmailSending' )
  , sequelize = injector.getInstance( 'sequelize' )
  , ejsFileRender = require( 'utils' ).ejsfilerender
  , sendgrid = require( 'utils' ).sendgrid;

var ProcessEmailSending = module.exports = Class.extend(
{

}, 

{

  EmailModel: models.ORM.Email,
  EmailAttachmentModel: models.ORM.EmailAttachment,

  bakeTemplate : ejsFileRender(),

  sendMail : sendgrid( config.sendgrid ),

  init: function( callback ) {
    debug( 'Checking for any emails that needs to be sent' );
    
    this.EmailModel
        .findAll({ where: { isDelivered: false, sentAttemps: { lte: 3 } } , limit: 10, include: [ this.EmailAttachmentModel ]})
        .success( this.proxy( 'loopOverEmailsToSend', callback ) )
        .error( callback );
  },
  
  loopOverEmailsToSend : function( callback, emails ){
    debug( 'Number of mails retrieved: '+ emails.length );
    
    async.forEach(
      emails,
      this.proxy( 'handleRenderAndMailSend' ),
      callback
    );

  },

  handleRenderAndMailSend : function( email, callback ){
    email.sentAttemps++;

    async.waterfall(
      [
        this.proxy( 'renderTemplate', email ),
        this.proxy( 'sendEmail' )
      ],
      function( err ){
        if ( err ) {            
          console.error( err );
        } else {
          email.isDelivered = true;
        }
        
        email
        .save()
        .success( function() {
            callback( null );
        })
        .error( callback );
    });
  },



  renderTemplate : function( email, callback ){
    var meta = JSON.parse( email.dump );

    if( meta.hasTemplate ){

      this.bakeTemplate({
          tplName     : meta.tplName
        , tplTitle    : meta.tplTitle || 'BoltHR: Autogenerated Notification'
        , companyName : meta.companyName
        , companyLogo : meta.companyLogo || ''
        , strHTML     : email.body
      })
      .then( function( html ) {
        callback( null, email, html );
      })
      .fail( callback );
    
    }else{  
      callback( null, email, email.body );
    };

  },

  renderAttachments: function( emailAttachments ){
    var files = [];
    emailAttachments.forEach(function( emailAttachment ){
      files.push({filename: emailAttachment.fileName, url: emailAttachment.filePath});
    });
    return files;
  },

  sendEmail : function( email, html, callback ){
    var meta = JSON.parse( email.dump );

    
    var payload = {
        to      : [ meta.toMail ]
      , bcc     : meta.usersBCC
      , subject : email.subject
      , html    : html
      , from    : meta.fromMail
      , fromname: meta.fromName
      , emailId : email.id
      , files: this.renderAttachments(email.emailAttachments)
    };

    if( meta.usersCC && meta.usersCC.length ){

      meta.usersCC.forEach(function( userEmail ){
        payload.to.push( userEmail );  
      });
    };

    this.sendMail( payload )
    .then( function() {
      callback( null );
    })
    .fail( callback );
  }

});